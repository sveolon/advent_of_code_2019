use std::collections::HashSet;

fn main() {
    /*let a = [
        ".###..#######..####..##...#",
        "########.#.###...###.#....#",
        "###..#...#######...#..####.",
        ".##.#.....#....##.#.#.....#",
        "###.#######.###..##......#.",
        "#..###..###.##.#.#####....#",
        "#.##..###....#####...##.##.",
        "####.##..#...#####.#..###.#",
        "#..#....####.####.###.#.###",
        "#..#..#....###...#####..#..",
        "##...####.######....#.####.",
        "####.##...###.####..##....#",
        "#.#..#.###.#.##.####..#...#",
        "..##..##....#.#..##..#.#..#",
        "##.##.#..######.#..#..####.",
        "#.....#####.##........#####",
        "###.#.#######..#.#.##..#..#",
        "###...#..#.#..##.##..#####.",
        ".##.#..#...#####.###.##.##.",
        "...#.#.######.#####.#.####.",
        "#..##..###...###.#.#..#.#.#",
        ".#..#.#......#.###...###..#",
        "#.##.#.#..#.#......#..#..##",
        ".##.##.##.#...##.##.##.#..#",
        "#.###.#.#...##..#####.###.#",
        "#.####.#..#.#.##.######.#..",
        ".#.#####.##...#...#.##...#.",
    ];*/
    let a = [".#..##.###...#######","##.############..##.",".#.######.########.#",".###.#######.####.#.","#####.##.#.##.###.##","..#####..#.#########","####################","#.####....###.#.#.##","##.#################","#####.##.###..####..","..######..##.#######","####.##.####...##..#",".#####..#.######.###","##...#.##########...","#.##########.#######",".####.#.###.###.#.##","....##.##.###..#####",".#.#.###########.###","#.#.#.#####.####.###","###.##.####.##.#..##"];
    let y_l = a.len();
    let x_l = a[0].len();

    let mut asteroids = Vec::new();
    for y in 0..y_l {
        for x in 0..x_l {
            if a[y][x..].chars().next().unwrap() == '#' {
                asteroids.push((x as i32, y as i32));
            }
        }
    }

    let mut res = 0;

    let mut center = asteroids[0];
    for curr in &asteroids {
        let mut hs = HashSet::new();
        for other in &asteroids {
            if curr == other {
                continue;
            }
            let x = other.0 - curr.0;
            let y = other.1 - curr.1;
            let gcd = num::integer::gcd(x, y);
            hs.insert((x / gcd, y / gcd));
        }
        if hs.len() > res {
            res = hs.len();
            center = *curr;
        }
    }
    println!("num visible:{}; center: x {},y {}", res, center.0, center.1);

    let mut bearings = Vec::new();
    for other in &asteroids {
        if center == *other {
            continue;
        }
        
        let x = other.0 - center.0;
        let y = other.1 - center.1;
        
        let len_2 = (x * x + y * y) as f64;
        let mut angle = (y as f64 / x as f64).atan();
        if y < 0 {
            angle += std::f64::consts::PI;
        } else if x < 0 {
            angle += 2.0 * std::f64::consts::PI;
        }
        bearings.push((angle, len_2, other.0, other.1));
    }
    
    bearings.sort_unstable_by(|a, b| {
        if num::abs(a.0 - b.0) > 1e-10 {
            a.0.partial_cmp(&b.0).unwrap()
        } else {
            a.1.partial_cmp(&b.1).unwrap()
        }
    });

    for i in 0..bearings.len() {
        println!(
            "{} {} {} {} {}",
            i, bearings[i].0, bearings[i].1, bearings[i].2, bearings[i].3
        );
    }
}
