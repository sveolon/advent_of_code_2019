use std::cmp::Ordering;
use std::collections::BinaryHeap;
use std::collections::HashMap;
use std::collections::HashSet;
use std::collections::VecDeque;
use std::usize;

#[derive(Clone, Eq, PartialEq)]
struct State {
    pos: (usize, usize),
    steps: usize,
    found_keys: HashSet<char>,
    visited: HashSet<(usize, usize)>,
    path: Vec<char>,
}

impl Ord for State {
    fn cmp(&self, other: &State) -> Ordering {
        other.steps.cmp(&self.steps)
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &State) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn clear_path_to_door(
    from: (usize, usize),
    to: (usize, usize),
    passages: &HashSet<(usize, usize)>,
    visited: &mut HashSet<(usize, usize)>,
) {
    let mut q = VecDeque::new();
    let p = vec![from];
    let v = HashSet::new();
    q.push_front((from, p, v));

    while q.len() > 0 {
        let mut c = q.pop_back().unwrap();
        if c.2.contains(&(c.0)) {
            continue;
        }
        c.2.insert(c.0);
        c.1.push(c.0);

        if c.0 == to {
            for p in c.1 {
                visited.remove(&p);
            }
            return;
        }
        let nexts = vec![
            ((c.0).0, (c.0).1 + 1),
            ((c.0).0, (c.0).1 - 1),
            ((c.0).0 + 1, (c.0).1),
            ((c.0).0 - 1, (c.0).1),
        ];
        for n in nexts {
            if passages.contains(&n) {
                q.push_front((n, c.1.clone(), (c.2).clone()))
            }
        }
    }
}

fn main() {
    let _a = [
        "#################################################################################",
        "#...#p........#..k........#.K..f........#...#.........#...........#.....#.......#",
        "#.#V#.#######.#P#########.#.#########.###.#.#######.###.###.#####.#.###.#.#####Y#",
        "#.#.#.#.C...#...#....u..#...#.A.....#...#.#.........#...#...#...#.#...#...#.....#",
        "#.#.#.#.###.#########.#.#####.#####.#.#.#.#########.#.###.#####.#.###.#####.#####",
        "#.#...#...#.#.......#.#.#.#...#...#.#.#.#...#...#...#.#...#.....#.....#.#...#...#",
        "#.#####.#.#.###.###.#.#.#.#.###.#.#.#.#.###.#.#.#####.#.###.###########.#.###.###",
        "#...#.#.#.#...#.#.#...#.#.#i#...#.#.#.#.#...#.#.....#.#...#.........#.....#.....#",
        "###.#.#.#.###.#.#.#####.#.#.#.#.#.#.###F#.###.#####.#.###.#######.#.#.#####.###.#",
        "#...#..n#.#.#...#.....#...#.#.#.#.#.#a..#.....#.#...#...#.#.....#.#.#.....#...#.#",
        "#O#######.#.#####.#####.###.#.#.#.#.#.###.#####.#.#.###J#.#.###.#.#######.#####.#",
        "#...#.....#.....#.....#.#...#.#.#.#...#.#.......#.#...#.#.#.#.#.#.........#.....#",
        "###.#.#####.#.###.###.#.#.#####.#######.#.#######.#####.#.#.#.#.###.#######.###.#",
        "#.#.#.#...#.#.....#.#...#.#.....#.......#.#t....#.#.....#l#.#.#...#...#....x#.#.#",
        "#.#.#.###.#.#######.#####.###.###.###.#.###.###.#.#.#####.#.#.###.###.#.#####.#.#",
        "#...#...#.#...#.........#...#....q#...#.#...#...#.#...#.#.#...#...#.#...#...#...#",
        "#.#####.#.###.#.###########I#######.###.#.#####.#.###.#.#.###.#.###.#####.#.#.###",
        "#.......#...#.#.#......z....#...#...#...#.#...#.#.......#.#...#.#.........#.#.#.#",
        "#########.#.#.#.#.###########.#.#.###.###.#.#.#.#.#######.#.###.#.#########G#.#.#",
        "#.....#...#.#...#.#...........#.#.#.#...#.#.#.#.#...#.....#.#...#.....#...#.#...#",
        "#W#.###.###.###.#.#####.#.#####.#.#.###.#.#.#.#.###.#.#####.#.#######.#.###.###.#",
        "#.#...#...#.....#...Z.#.#...#.#...#.#...#...#.#...#.#.....#.#.#.......#.#...#...#",
        "#.###.###.#############.###.#.#####.#.#######.###.#.#####.#.###.#.#####.#.###.###",
        "#...#...#.#.....#.....#...#.#.......#.#.#...#.#.#.#.#.....#...#.#.#...#.....#...#",
        "#.#####.#.#.###.###.#.###.#.#######.#.#.#.#.#.#.#.#.#.###.###.###.#.#.#.#######.#",
        "#.#.....#...#...#...#.#...#...#...#...#.#.#.#.#.#.#.#.#.#.#.#...#.#.#...#.......#",
        "###.###.#####.###.###.#####.#.#.#.#.###.#.#.#.#.#.###.#.#.#.###.#.###.###.#######",
        "#...#.....#.#.#...#.#.#...#.#.#.#.#.....#.#...#.#.....#...#...#.#...#...#.#.....#",
        "#.#######.#.#.###.#.#.#.#.###.#.#.#####.#.#####.#######.#####.#.###.#####.#.###.#",
        "#.#.....#.#.#.....#.#.#.#...#...#...#...#...#.....#...........#...#.........#...#",
        "#.#.###.#.#.#######.#.#.###.#.#####.#.###.#.#.#.###.#########.###.#####.#######.#",
        "#r#...#.#...#.......#.#...#.#.#.....#.#.#.#.#.#.........#...#...#.....#...#...#.#",
        "#.###.#.#####.#.#####.#.#.#.###.#####.#.#.#.###########.#.#.#.#######.#####.#.###",
        "#.....#.#...#.#.#.....#.#.#.....#.....#.#.#.......#...#.#.#.#.#.....#.#.....#...#",
        "#.#####.#.#.#.#.#.#######.#######.#####.#.#######.#.#.###.#.###.###.#.#.#######.#",
        "#.#.#...#.#.#.#.#.#.....#.....#.#.#.....#.#.....#...#.....#...#...#.#...#.......#",
        "#.#.#.###.#.#.#.#.###.#.#.###.#.#.###.#.#.#.###.#############.###.#.#####.#######",
        "#.#.#...#.#...#.#.#...#.#...#.#...#...#.#.#.#...#........m..#...#.#.....#.....#.#",
        "#.#.###.#.#####.#.#.###.#####.#.###.###.#.#.#.###.#########.#.###.#####.#####.#.#",
        "#.....#.......#.....#.........#.....#.......#.....#.........#.........#.........#",
        "#######################################.@.#######################################",
        "#.#...M.........#.H...............#.........#h....#...#.....#.#..............b..#",
        "#.#.###########.#####.###########.#.###.###.#.#.#.#.#.###.#.#.#.###############.#",
        "#.#...........#.......#.........#...#...#...#.#.#...#.#...#.#.......#.D.#.....#.#",
        "#.###########.###.#####.#####.#######.###.###.#.#####.#.###.#########.#.#.###.#.#",
        "#.....#.....#...#.#...#.#...#.....#...#.#.....#.#...#.#.#...#.........#...#.#.#.#",
        "#.###.#.###.###.###.#.#.###.#####.#.###.#######.#.#.#.#.#.###.#############.#.#.#",
        "#...#.#.#.#...#.....#.#.........#...#...#.....#.#.#.#...#.#...#.............#.#.#",
        "#.###.#.#.#.#########.#########.#####.###.###.#.###.#####T#.#.###.#####.#####.#.#",
        "#.#...#...#.....#...#.#.......#...#.....#.#.....#...#...#.#.#...#.....#.......#.#",
        "#.#.###.#####.###.#.#.#.#####.###.#####.#.#######.#.#.###.#.###.#####.#########.#",
        "#.#g....#.....#...#...#...#..d..#.......#...#.#...#.#...#.#...#...#.#.......#...#",
        "#######.#.###.#.#####.#####.###########.###.#.#.#.#.###.#.#######.#.#######.###.#",
        "#.....#.#...#.#.....#.#...#.......#...#.#...#...#.#.....#.....#...#.......#.#...#",
        "#.###.#####.#######.###.#.#.###.###.#.#.#.#######.#.#########.#.#####.#####.#.#.#",
        "#.#.E.....#...#...#.....#.#...#.....#.#.#.#.......#.#.......#...#.....#.....#.#.#",
        "#.#.#####.###.#.#.#######.###.#######.#.#.#.#######.#.#.###.#####.###.#.#####.#.#",
        "#.#.#...#.....#.#.........#...#.....#.#.#.#...#.....#.#...#.#.....#w..#...#..s#.#",
        "#.###.#.#####.#.#.#########.###.###.#.#.#.###.#######.###.###.###.###.###.###.#.#",
        "#.#...#.....#.#.#.#...#.#...#...#...#...#.#...#.......#.#.......#...#...#.....#.#",
        "#.#.#######.#.#.###.#.#.#.###.###.#.#####.#.###.#######.#######.###.#.#########.#",
        "#.#.#.....#.#.#.....#.#...#.#.#...#.....#.#...............#...#...#.#.#.........#",
        "#.#.#.###.#.#.#########.###.#.#.#######.#.###############.#.#####.#.###.#########",
        "#.#.#.#...#.#...#...#...#.....#...#.....#.#...........#...#.#.....#.#...#.......#",
        "#.#.###.#.#.#####.#.#.#########.#.#######.#.#########.#####.#######.#.###.#####.#",
        "#.#.#...#.#.....L.#.#.#.......#.#.......#...#.....#.#...#...#.....#.#.#.......#.#",
        "#.#.#.###.#########.#.#.#####.#.#######.#.###.#.#.#.###.#.###.###.#.#.#######.#.#",
        "#.#.#.#.#.#.......#...#...#...#.#.......#.#.#.#.#.....#.#.#...#...#.#.....#...#.#",
        "#.#.#.#.#.#.###.#.#######.#.#####.#######.#.#.#.#######.#.###.#.###.#####.#.###.#",
        "#.#...#.#.#.#...#.#.......#.#...#....c..#.#...#.#.....#.#.....#.#.......#.#.R.#.#",
        "#.#####.#.###S###.#.#.#####.#.#.#######.#.#####.#.###.#.#######.#.###.###.#####.#",
        "#.......#.....#...#.#.#...#...#.....#...#.....#.#.#...#...#.....#...#...#...#e..#",
        "#.#####.#######B#####.#.###########.#.#######.#.#.#.###.###.#######.###.###.#.#.#",
        "#.....#.........#.....#.....#.....#.#...#...#...#.#...#...#.....#...#.....#.#.#.#",
        "#####.###########.#####.###.#.###.#.###.###.###.#.###.###.#####.#####.###.#.#.#.#",
        "#...#.....#.......#.#.....#.#...#.#...#.#.....#.#.#.......#...#...#...#...#.#.#.#",
        "###.#####.#.#######.#.#####N###.#.###.#.#.#####.#.#######.#.#.###.#.#######.#.#.#",
        "#...#.....#...#..o....#.#...#...#...#...#.#.....#.......#.#j#...#y#.......#.#.#.#",
        "#.###.#######.#.#######.#.###.###.#####.#.#.###########.###.#.###.#.#####.#.#X#.#",
        "#.............#........v#.......#.U.....#.Q...........#.....#.....#.....#.....#.#",
        "#################################################################################",
    ];

    //let _a = ["#########", "#b.A.@.a#", "#########"];
    let _a3 = [
        "#################",
        "#i.G..c...e..H.p#",
        "########.########",
        "#j.A..b...f..D.o#",
        "########@########",
        "#k.E..a...g..B.n#",
        "########.########",
        "#l.F..d...h..C.m#",
        "#################",
    ];
    let _a1 = ["#########", "#b.A.@.a#", "#########"];

    let _a2 = [
        "########################",
        "#f.D.E.e.C.b.A.@.a.B.c.#",
        "######################.#",
        "#d.....................#",
        "########################",
    ];

    let a = [
        "########################",
        "#@..............ac.GI.b#",
        "###d#e#f################",
        "###A#B#C################",
        "###g#h#i################",
        "########################",
    ];

    let max_y: usize = a.len();
    let max_x: usize = a[0].len();

    let mut passages = HashSet::new();
    let mut doors = HashMap::new();
    let mut doors_inv = HashMap::new();
    let mut keys = HashMap::new();
    let mut keys_inv = HashMap::new();
    let mut curr = (0, 0);

    for y in 0..max_y {
        for x in 0..max_x {
            let c = a[y].chars().nth(x).unwrap();

            if c == '#' {
                continue;
            }
            passages.insert((x, y));
            if c == '@' {
                curr = (x, y);
            } else if 'a' <= c && c <= 'z' {
                keys.insert(c, (x, y));
                keys_inv.insert((x, y), c);
            } else if 'A' <= c && c <= 'Z' {
                doors.insert(c, (x, y));
                doors_inv.insert((x, y), c);
            }
        }
    }

    print!("\n\t");
    for x in 0..max_x {
        print!("{}", x / 10);
    }
    print!("\n\t");
    for x in 0..max_x {
        print!("{}", x % 10);
    }
    for y in 0..max_y {
        print!("\n{}\t", y);
        for x in 0..max_x {
            if doors_inv.contains_key(&(x, y)) {
                print!("{}", doors_inv[&(x, y)]);
            } else if keys_inv.contains_key(&(x, y)) {
                print!("{}", keys_inv[&(x, y)]);
            } else if curr.0 == x && curr.1 == y {
                print!("@");
            } else if passages.contains(&(x, y)) {
                print!(".");
            } else {
                print!("#");
            }
        }
    }
    print!("\n\n");

    let mut queue = BinaryHeap::new();
    //let mut queue = VecDeque::new();
    let found_keys = HashSet::new();
    let mut visited = HashSet::new();

    visited.insert(curr);
    //queue.push_front(State {
    queue.push(State {
        pos: curr,
        steps: 0,
        found_keys: found_keys,
        visited: visited,
        path: vec!['@'],
    });
    let mut i = 0;
    while queue.len() > 0 {
        let mut should_ret = false;
        let mut should_cont = false;

        if i % 10 == 0 {
            //println!("q: {}; ", queue.len());
        }
        i += 1;

        //let mut state = queue.pop_front().unwrap();
        let mut state = queue.pop().unwrap();
        let x = state.pos.0;
        let y = state.pos.1;

        //println!("pop ({} {})", x, y);

        if keys_inv.contains_key(&(x, y)) {
            // it's a key
            let key = &keys_inv[&(x, y)];
            if state.found_keys.contains(key) { // already have this key
                 // skip
            } else {
                // didn't have this key
                state.found_keys.insert(*key);
                //state.visited.clear();
                let key_big = (*key as u8 - 'a' as u8 + 'A' as u8) as char;
                if doors.contains_key(&key_big) {
                    clear_path_to_door((x, y), doors[&key_big], &passages, &mut state.visited);
                }
                state.path.push(*key);
            }
        } else if doors_inv.contains_key(&(x, y)) {
            // it's a door
            let key = (doors_inv[&(x, y)] as u8 - 'A' as u8 + 'a' as u8) as char;

            // closed door
            if state.found_keys.contains(&key) {
                // we have a key
                state.path.push(doors_inv[&(x, y)]);
            //state.visited.clear();
            } else {
                // locked and no key - treat as a wall for now
                should_cont = true;
                state.visited.insert((x, y));
                continue;
            }
        }

        state.visited.insert((x, y));

        if state.found_keys.len() == keys.len() {
            println!(
                "result: {} ({} == {})",
                state.steps,
                state.found_keys.len(),
                keys.len()
            );
            should_ret = true;
        }

        if !should_ret && !should_cont {
            if !state.visited.contains(&(x, y + 1)) && passages.contains(&(x, y + 1)) {
                //println!("adding ({} {})", x, y + 1);
                //queue.push_back(State {
                queue.push(State {
                    pos: (x, y + 1),
                    steps: state.steps + 1,
                    found_keys: state.found_keys.clone(),
                    visited: state.visited.clone(),
                    path: state.path.clone(),
                });
            }
            if !state.visited.contains(&(x, y - 1)) && passages.contains(&(x, y - 1)) {
                //println!("adding ({} {})", x, y - 1);
                //queue.push_back(State {
                queue.push(State {
                    pos: (x, y - 1),
                    steps: state.steps + 1,
                    found_keys: state.found_keys.clone(),
                    visited: state.visited.clone(),
                    path: state.path.clone(),
                });
            }

            if !state.visited.contains(&(x + 1, y)) && passages.contains(&(x + 1, y)) {
                //println!("adding ({} {})", x + 1, y);
                //queue.push_back(State {
                queue.push(State {
                    pos: (x + 1, y),
                    steps: state.steps + 1,
                    found_keys: state.found_keys.clone(),
                    visited: state.visited.clone(),
                    path: state.path.clone(),
                });
            }
            if !state.visited.contains(&(x - 1, y)) && passages.contains(&(x - 1, y)) {
                //println!("adding ({} {})", x - 1, y);
                //queue.push_back(State {
                queue.push(State {
                    pos: (x - 1, y),
                    steps: state.steps + 1,
                    found_keys: state.found_keys.clone(),
                    visited: state.visited.clone(),
                    path: state.path.clone(),
                });
            }
        }

        /*print!("\n");
        for v in &state.path {
            print!("{},", v);
        }*/
        if should_ret { return; }
    }
}
