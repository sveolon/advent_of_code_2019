use std::cmp::Ordering;
use std::collections::BinaryHeap;
use std::collections::HashMap;
use std::collections::HashSet;
use std::usize;

#[derive(Clone, Eq, PartialEq)]
struct State {
    pos: (usize, usize),
    steps: usize,
    found_keys: HashSet<char>,
    found_doors: HashSet<char>,
    visited: HashSet<(usize, usize)>,
}

impl Ord for State {
    fn cmp(&self, other: &State) -> Ordering {
        other.steps.cmp(&self.steps)
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &State) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn main() {
    let _aa = [
        "#################################################################################",
        "#...#p........#..k........#.K..f........#...#.........#...........#.....#.......#",
        "#.#V#.#######.#P#########.#.#########.###.#.#######.###.###.#####.#.###.#.#####Y#",
        "#.#.#.#.C...#...#....u..#...#.A.....#...#.#.........#...#...#...#.#...#...#.....#",
        "#.#.#.#.###.#########.#.#####.#####.#.#.#.#########.#.###.#####.#.###.#####.#####",
        "#.#...#...#.#.......#.#.#.#...#...#.#.#.#...#...#...#.#...#.....#.....#.#...#...#",
        "#.#####.#.#.###.###.#.#.#.#.###.#.#.#.#.###.#.#.#####.#.###.###########.#.###.###",
        "#...#.#.#.#...#.#.#...#.#.#i#...#.#.#.#.#...#.#.....#.#...#.........#.....#.....#",
        "###.#.#.#.###.#.#.#####.#.#.#.#.#.#.###F#.###.#####.#.###.#######.#.#.#####.###.#",
        "#...#..n#.#.#...#.....#...#.#.#.#.#.#a..#.....#.#...#...#.#.....#.#.#.....#...#.#",
        "#O#######.#.#####.#####.###.#.#.#.#.#.###.#####.#.#.###J#.#.###.#.#######.#####.#",
        "#...#.....#.....#.....#.#...#.#.#.#...#.#.......#.#...#.#.#.#.#.#.........#.....#",
        "###.#.#####.#.###.###.#.#.#####.#######.#.#######.#####.#.#.#.#.###.#######.###.#",
        "#.#.#.#...#.#.....#.#...#.#.....#.......#.#t....#.#.....#l#.#.#...#...#....x#.#.#",
        "#.#.#.###.#.#######.#####.###.###.###.#.###.###.#.#.#####.#.#.###.###.#.#####.#.#",
        "#...#...#.#...#.........#...#....q#...#.#...#...#.#...#.#.#...#...#.#...#...#...#",
        "#.#####.#.###.#.###########I#######.###.#.#####.#.###.#.#.###.#.###.#####.#.#.###",
        "#.......#...#.#.#......z....#...#...#...#.#...#.#.......#.#...#.#.........#.#.#.#",
        "#########.#.#.#.#.###########.#.#.###.###.#.#.#.#.#######.#.###.#.#########G#.#.#",
        "#.....#...#.#...#.#...........#.#.#.#...#.#.#.#.#...#.....#.#...#.....#...#.#...#",
        "#W#.###.###.###.#.#####.#.#####.#.#.###.#.#.#.#.###.#.#####.#.#######.#.###.###.#",
        "#.#...#...#.....#...Z.#.#...#.#...#.#...#...#.#...#.#.....#.#.#.......#.#...#...#",
        "#.###.###.#############.###.#.#####.#.#######.###.#.#####.#.###.#.#####.#.###.###",
        "#...#...#.#.....#.....#...#.#.......#.#.#...#.#.#.#.#.....#...#.#.#...#.....#...#",
        "#.#####.#.#.###.###.#.###.#.#######.#.#.#.#.#.#.#.#.#.###.###.###.#.#.#.#######.#",
        "#.#.....#...#...#...#.#...#...#...#...#.#.#.#.#.#.#.#.#.#.#.#...#.#.#...#.......#",
        "###.###.#####.###.###.#####.#.#.#.#.###.#.#.#.#.#.###.#.#.#.###.#.###.###.#######",
        "#...#.....#.#.#...#.#.#...#.#.#.#.#.....#.#...#.#.....#...#...#.#...#...#.#.....#",
        "#.#######.#.#.###.#.#.#.#.###.#.#.#####.#.#####.#######.#####.#.###.#####.#.###.#",
        "#.#.....#.#.#.....#.#.#.#...#...#...#...#...#.....#...........#...#.........#...#",
        "#.#.###.#.#.#######.#.#.###.#.#####.#.###.#.#.#.###.#########.###.#####.#######.#",
        "#r#...#.#...#.......#.#...#.#.#.....#.#.#.#.#.#.........#...#...#.....#...#...#.#",
        "#.###.#.#####.#.#####.#.#.#.###.#####.#.#.#.###########.#.#.#.#######.#####.#.###",
        "#.....#.#...#.#.#.....#.#.#.....#.....#.#.#.......#...#.#.#.#.#.....#.#.....#...#",
        "#.#####.#.#.#.#.#.#######.#######.#####.#.#######.#.#.###.#.###.###.#.#.#######.#",
        "#.#.#...#.#.#.#.#.#.....#.....#.#.#.....#.#.....#...#.....#...#...#.#...#.......#",
        "#.#.#.###.#.#.#.#.###.#.#.###.#.#.###.#.#.#.###.#############.###.#.#####.#######",
        "#.#.#...#.#...#.#.#...#.#...#.#...#...#.#.#.#...#........m..#...#.#.....#.....#.#",
        "#.#.###.#.#####.#.#.###.#####.#.###.###.#.#.#.###.#########.#.###.#####.#####.#.#",
        "#.....#.......#.....#.........#.....#.......#.....#.........#.........#.........#",
        "#######################################.@.#######################################",
        "#.#...M.........#.H...............#.........#h....#...#.....#.#..............b..#",
        "#.#.###########.#####.###########.#.###.###.#.#.#.#.#.###.#.#.#.###############.#",
        "#.#...........#.......#.........#...#...#...#.#.#...#.#...#.#.......#.D.#.....#.#",
        "#.###########.###.#####.#####.#######.###.###.#.#####.#.###.#########.#.#.###.#.#",
        "#.....#.....#...#.#...#.#...#.....#...#.#.....#.#...#.#.#...#.........#...#.#.#.#",
        "#.###.#.###.###.###.#.#.###.#####.#.###.#######.#.#.#.#.#.###.#############.#.#.#",
        "#...#.#.#.#...#.....#.#.........#...#...#.....#.#.#.#...#.#...#.............#.#.#",
        "#.###.#.#.#.#########.#########.#####.###.###.#.###.#####T#.#.###.#####.#####.#.#",
        "#.#...#...#.....#...#.#.......#...#.....#.#.....#...#...#.#.#...#.....#.......#.#",
        "#.#.###.#####.###.#.#.#.#####.###.#####.#.#######.#.#.###.#.###.#####.#########.#",
        "#.#g....#.....#...#...#...#..d..#.......#...#.#...#.#...#.#...#...#.#.......#...#",
        "#######.#.###.#.#####.#####.###########.###.#.#.#.#.###.#.#######.#.#######.###.#",
        "#.....#.#...#.#.....#.#...#.......#...#.#...#...#.#.....#.....#...#.......#.#...#",
        "#.###.#####.#######.###.#.#.###.###.#.#.#.#######.#.#########.#.#####.#####.#.#.#",
        "#.#.E.....#...#...#.....#.#...#.....#.#.#.#.......#.#.......#...#.....#.....#.#.#",
        "#.#.#####.###.#.#.#######.###.#######.#.#.#.#######.#.#.###.#####.###.#.#####.#.#",
        "#.#.#...#.....#.#.........#...#.....#.#.#.#...#.....#.#...#.#.....#w..#...#..s#.#",
        "#.###.#.#####.#.#.#########.###.###.#.#.#.###.#######.###.###.###.###.###.###.#.#",
        "#.#...#.....#.#.#.#...#.#...#...#...#...#.#...#.......#.#.......#...#...#.....#.#",
        "#.#.#######.#.#.###.#.#.#.###.###.#.#####.#.###.#######.#######.###.#.#########.#",
        "#.#.#.....#.#.#.....#.#...#.#.#...#.....#.#...............#...#...#.#.#.........#",
        "#.#.#.###.#.#.#########.###.#.#.#######.#.###############.#.#####.#.###.#########",
        "#.#.#.#...#.#...#...#...#.....#...#.....#.#...........#...#.#.....#.#...#.......#",
        "#.#.###.#.#.#####.#.#.#########.#.#######.#.#########.#####.#######.#.###.#####.#",
        "#.#.#...#.#.....L.#.#.#.......#.#.......#...#.....#.#...#...#.....#.#.#.......#.#",
        "#.#.#.###.#########.#.#.#####.#.#######.#.###.#.#.#.###.#.###.###.#.#.#######.#.#",
        "#.#.#.#.#.#.......#...#...#...#.#.......#.#.#.#.#.....#.#.#...#...#.#.....#...#.#",
        "#.#.#.#.#.#.###.#.#######.#.#####.#######.#.#.#.#######.#.###.#.###.#####.#.###.#",
        "#.#...#.#.#.#...#.#.......#.#...#....c..#.#...#.#.....#.#.....#.#.......#.#.R.#.#",
        "#.#####.#.###S###.#.#.#####.#.#.#######.#.#####.#.###.#.#######.#.###.###.#####.#",
        "#.......#.....#...#.#.#...#...#.....#...#.....#.#.#...#...#.....#...#...#...#e..#",
        "#.#####.#######B#####.#.###########.#.#######.#.#.#.###.###.#######.###.###.#.#.#",
        "#.....#.........#.....#.....#.....#.#...#...#...#.#...#...#.....#...#.....#.#.#.#",
        "#####.###########.#####.###.#.###.#.###.###.###.#.###.###.#####.#####.###.#.#.#.#",
        "#...#.....#.......#.#.....#.#...#.#...#.#.....#.#.#.......#...#...#...#...#.#.#.#",
        "###.#####.#.#######.#.#####N###.#.###.#.#.#####.#.#######.#.#.###.#.#######.#.#.#",
        "#...#.....#...#..o....#.#...#...#...#...#.#.....#.......#.#j#...#y#.......#.#.#.#",
        "#.###.#######.#.#######.#.###.###.#####.#.#.###########.###.#.###.#.#####.#.#X#.#",
        "#.............#........v#.......#.U.....#.Q...........#.....#.....#.....#.....#.#",
        "#################################################################################",
    ];

    let _a = ["#########", "#b.A.@.a#", "#########"];
    let a = [
        "########################",
        "#f.D.E.e.C.b.A.@.a.B.c.#",
        "######################.#",
        "#d.....................#",
        "########################",
    ];

    let max_y: usize = a.len();
    let max_x: usize = a[0].len();

    let mut passages = HashSet::new();
    let mut doors = HashMap::new();
    let mut doors_inv = HashMap::new();
    let mut keys = HashMap::new();
    let mut keys_inv = HashMap::new();
    let mut curr = (0, 0);

    for y in 0..max_y {
        for x in 0..max_x {
            let c = a[y].chars().nth(x).unwrap();

            if c == '#' {
                continue;
            }
            passages.insert((x, y));
            if c == '@' {
                curr = (x, y);
            } else if 'a' <= c && c <= 'z' {
                keys.insert(c, (x, y));
                keys_inv.insert((x, y), c);
            } else if 'A' <= c && c <= 'Z' {
                doors.insert(c, (x, y));
                doors_inv.insert((x, y), c);
            }
        }
    }

    print!("\n\t");
    for x in 0..max_x {
        print!("{}", x / 10);
    }
    print!("\n\t");
    for x in 0..max_x {
        print!("{}", x % 10);
    }
    for y in 0..max_y {
        print!("\n{}\t", y);
        for x in 0..max_x {
            if doors_inv.contains_key(&(x, y)) {
                print!("{}", doors_inv[&(x, y)]);
            } else if keys_inv.contains_key(&(x, y)) {
                print!("{}", keys_inv[&(x, y)]);
            } else if curr.0 == x && curr.1 == y {
                print!("@");
            } else if passages.contains(&(x, y)) {
                print!(".");
            } else {
                print!("#");
            }
        }
    }
    print!("\n\n");

    let mut queue = BinaryHeap::new();
    let found_keys = HashSet::new();
    let found_doors = HashSet::new();
    let mut visited = HashSet::new();

    visited.insert(curr);
    queue.push(State {
        pos: curr,
        steps: 0,
        found_keys: found_keys,
        found_doors: found_doors,
        visited: visited,
    });
    let mut i = 0;
    while queue.len() > 0 {
        if i % 10 == 0 {
            //println!("q: {}; ", queue.len());
        }
        i += 1;

        let mut state = queue.pop().unwrap();
        let x = state.pos.0;
        let y = state.pos.1;

        if keys_inv.contains_key(&(x, y)) {
            let key = &keys_inv[&(x, y)];
            if state.found_keys.contains(key) {
                // skip
            } else {
                state.found_keys.insert(*key);
                state.visited.clear();
                state.visited.insert((x, y));
            }
        } else if doors_inv.contains_key(&(x, y)) {
            let key = (doors_inv[&(x, y)] as u8 - 'A' as u8 + 'a' as u8) as char;
            if state.found_keys.contains(&key) && !state.found_doors.contains(&key) {
                state.found_doors.insert(key);
                state.visited.clear();
                state.visited.insert((x, y));
            } else {
                state.visited.insert((x, y));
                continue; // treat as a wall for now
            }
        }
        state.visited.insert((x, y));

        if state.found_keys.len() == keys.len() {
            println!(
                "result: {} ({} == {})",
                state.steps,
                state.found_keys.len(),
                keys.len()
            );
        println!(
            "{}) ({}, {}): s {}, v {}, k {}, d {}, q {}",
            i,
            x,
            y,
            state.steps,
            state.visited.len(),
            state.found_keys.len(),
            state.found_doors.len(),
            queue.len()
        );
            return;
        }

        if !state.visited.contains(&(x, y + 1)) && passages.contains(&(x, y + 1)) {
            queue.push(State {
                pos: (x, y + 1),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
            });
        }
        if !state.visited.contains(&(x, y - 1)) && passages.contains(&(x, y - 1)) {
            queue.push(State {
                pos: (x, y - 1),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
            });
        }
        if !state.visited.contains(&(x + 1, y)) && passages.contains(&(x + 1, y)) {
            queue.push(State {
                pos: (x + 1, y),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
            });
        }
        if !state.visited.contains(&(x - 1, y)) && passages.contains(&(x - 1, y)) {
            queue.push(State {
                pos: (x - 1, y),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
            });
        }
        
        println!(
            "{}) ({}, {}): s {}, v {}, k {}, d {}, q {}",
            i,
            x,
            y,
            state.steps,
            state.visited.len(),
            state.found_keys.len(),
            state.found_doors.len(),
            queue.len()
        );
    }
}
