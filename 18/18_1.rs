use std::cmp::Ordering;
use std::collections::BinaryHeap;
use std::collections::VecDeque;
use std::collections::HashMap;
use std::collections::HashSet;
use std::usize;

#[derive(Clone, Eq, PartialEq)]
struct State {
    pos: (usize, usize),
    steps: usize,
    found_keys: HashSet<char>,
    found_doors: HashSet<char>,
    visited: HashSet<(usize, usize)>,
    path: Vec<(usize, usize)>
}

impl Ord for State {
    fn cmp(&self, other: &State) -> Ordering {
        other.steps.cmp(&self.steps)
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &State) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn main() {
    let _a = [
        "#################################################################################",
        "#...#p........#..k........#.K..f........#...#.........#...........#.....#.......#",
        "#.#V#.#######.#P#########.#.#########.###.#.#######.###.###.#####.#.###.#.#####Y#",
        "#.#.#.#.C...#...#....u..#...#.A.....#...#.#.........#...#...#...#.#...#...#.....#",
        "#.#.#.#.###.#########.#.#####.#####.#.#.#.#########.#.###.#####.#.###.#####.#####",
        "#.#...#...#.#.......#.#.#.#...#...#.#.#.#...#...#...#.#...#.....#.....#.#...#...#",
        "#.#####.#.#.###.###.#.#.#.#.###.#.#.#.#.###.#.#.#####.#.###.###########.#.###.###",
        "#...#.#.#.#...#.#.#...#.#.#i#...#.#.#.#.#...#.#.....#.#...#.........#.....#.....#",
        "###.#.#.#.###.#.#.#####.#.#.#.#.#.#.###F#.###.#####.#.###.#######.#.#.#####.###.#",
        "#...#..n#.#.#...#.....#...#.#.#.#.#.#a..#.....#.#...#...#.#.....#.#.#.....#...#.#",
        "#O#######.#.#####.#####.###.#.#.#.#.#.###.#####.#.#.###J#.#.###.#.#######.#####.#",
        "#...#.....#.....#.....#.#...#.#.#.#...#.#.......#.#...#.#.#.#.#.#.........#.....#",
        "###.#.#####.#.###.###.#.#.#####.#######.#.#######.#####.#.#.#.#.###.#######.###.#",
        "#.#.#.#...#.#.....#.#...#.#.....#.......#.#t....#.#.....#l#.#.#...#...#....x#.#.#",
        "#.#.#.###.#.#######.#####.###.###.###.#.###.###.#.#.#####.#.#.###.###.#.#####.#.#",
        "#...#...#.#...#.........#...#....q#...#.#...#...#.#...#.#.#...#...#.#...#...#...#",
        "#.#####.#.###.#.###########I#######.###.#.#####.#.###.#.#.###.#.###.#####.#.#.###",
        "#.......#...#.#.#......z....#...#...#...#.#...#.#.......#.#...#.#.........#.#.#.#",
        "#########.#.#.#.#.###########.#.#.###.###.#.#.#.#.#######.#.###.#.#########G#.#.#",
        "#.....#...#.#...#.#...........#.#.#.#...#.#.#.#.#...#.....#.#...#.....#...#.#...#",
        "#W#.###.###.###.#.#####.#.#####.#.#.###.#.#.#.#.###.#.#####.#.#######.#.###.###.#",
        "#.#...#...#.....#...Z.#.#...#.#...#.#...#...#.#...#.#.....#.#.#.......#.#...#...#",
        "#.###.###.#############.###.#.#####.#.#######.###.#.#####.#.###.#.#####.#.###.###",
        "#...#...#.#.....#.....#...#.#.......#.#.#...#.#.#.#.#.....#...#.#.#...#.....#...#",
        "#.#####.#.#.###.###.#.###.#.#######.#.#.#.#.#.#.#.#.#.###.###.###.#.#.#.#######.#",
        "#.#.....#...#...#...#.#...#...#...#...#.#.#.#.#.#.#.#.#.#.#.#...#.#.#...#.......#",
        "###.###.#####.###.###.#####.#.#.#.#.###.#.#.#.#.#.###.#.#.#.###.#.###.###.#######",
        "#...#.....#.#.#...#.#.#...#.#.#.#.#.....#.#...#.#.....#...#...#.#...#...#.#.....#",
        "#.#######.#.#.###.#.#.#.#.###.#.#.#####.#.#####.#######.#####.#.###.#####.#.###.#",
        "#.#.....#.#.#.....#.#.#.#...#...#...#...#...#.....#...........#...#.........#...#",
        "#.#.###.#.#.#######.#.#.###.#.#####.#.###.#.#.#.###.#########.###.#####.#######.#",
        "#r#...#.#...#.......#.#...#.#.#.....#.#.#.#.#.#.........#...#...#.....#...#...#.#",
        "#.###.#.#####.#.#####.#.#.#.###.#####.#.#.#.###########.#.#.#.#######.#####.#.###",
        "#.....#.#...#.#.#.....#.#.#.....#.....#.#.#.......#...#.#.#.#.#.....#.#.....#...#",
        "#.#####.#.#.#.#.#.#######.#######.#####.#.#######.#.#.###.#.###.###.#.#.#######.#",
        "#.#.#...#.#.#.#.#.#.....#.....#.#.#.....#.#.....#...#.....#...#...#.#...#.......#",
        "#.#.#.###.#.#.#.#.###.#.#.###.#.#.###.#.#.#.###.#############.###.#.#####.#######",
        "#.#.#...#.#...#.#.#...#.#...#.#...#...#.#.#.#...#........m..#...#.#.....#.....#.#",
        "#.#.###.#.#####.#.#.###.#####.#.###.###.#.#.#.###.#########.#.###.#####.#####.#.#",
        "#.....#.......#.....#.........#.....#.......#.....#.........#.........#.........#",
        "#######################################.@.#######################################",
        "#.#...M.........#.H...............#.........#h....#...#.....#.#..............b..#",
        "#.#.###########.#####.###########.#.###.###.#.#.#.#.#.###.#.#.#.###############.#",
        "#.#...........#.......#.........#...#...#...#.#.#...#.#...#.#.......#.D.#.....#.#",
        "#.###########.###.#####.#####.#######.###.###.#.#####.#.###.#########.#.#.###.#.#",
        "#.....#.....#...#.#...#.#...#.....#...#.#.....#.#...#.#.#...#.........#...#.#.#.#",
        "#.###.#.###.###.###.#.#.###.#####.#.###.#######.#.#.#.#.#.###.#############.#.#.#",
        "#...#.#.#.#...#.....#.#.........#...#...#.....#.#.#.#...#.#...#.............#.#.#",
        "#.###.#.#.#.#########.#########.#####.###.###.#.###.#####T#.#.###.#####.#####.#.#",
        "#.#...#...#.....#...#.#.......#...#.....#.#.....#...#...#.#.#...#.....#.......#.#",
        "#.#.###.#####.###.#.#.#.#####.###.#####.#.#######.#.#.###.#.###.#####.#########.#",
        "#.#g....#.....#...#...#...#..d..#.......#...#.#...#.#...#.#...#...#.#.......#...#",
        "#######.#.###.#.#####.#####.###########.###.#.#.#.#.###.#.#######.#.#######.###.#",
        "#.....#.#...#.#.....#.#...#.......#...#.#...#...#.#.....#.....#...#.......#.#...#",
        "#.###.#####.#######.###.#.#.###.###.#.#.#.#######.#.#########.#.#####.#####.#.#.#",
        "#.#.E.....#...#...#.....#.#...#.....#.#.#.#.......#.#.......#...#.....#.....#.#.#",
        "#.#.#####.###.#.#.#######.###.#######.#.#.#.#######.#.#.###.#####.###.#.#####.#.#",
        "#.#.#...#.....#.#.........#...#.....#.#.#.#...#.....#.#...#.#.....#w..#...#..s#.#",
        "#.###.#.#####.#.#.#########.###.###.#.#.#.###.#######.###.###.###.###.###.###.#.#",
        "#.#...#.....#.#.#.#...#.#...#...#...#...#.#...#.......#.#.......#...#...#.....#.#",
        "#.#.#######.#.#.###.#.#.#.###.###.#.#####.#.###.#######.#######.###.#.#########.#",
        "#.#.#.....#.#.#.....#.#...#.#.#...#.....#.#...............#...#...#.#.#.........#",
        "#.#.#.###.#.#.#########.###.#.#.#######.#.###############.#.#####.#.###.#########",
        "#.#.#.#...#.#...#...#...#.....#...#.....#.#...........#...#.#.....#.#...#.......#",
        "#.#.###.#.#.#####.#.#.#########.#.#######.#.#########.#####.#######.#.###.#####.#",
        "#.#.#...#.#.....L.#.#.#.......#.#.......#...#.....#.#...#...#.....#.#.#.......#.#",
        "#.#.#.###.#########.#.#.#####.#.#######.#.###.#.#.#.###.#.###.###.#.#.#######.#.#",
        "#.#.#.#.#.#.......#...#...#...#.#.......#.#.#.#.#.....#.#.#...#...#.#.....#...#.#",
        "#.#.#.#.#.#.###.#.#######.#.#####.#######.#.#.#.#######.#.###.#.###.#####.#.###.#",
        "#.#...#.#.#.#...#.#.......#.#...#....c..#.#...#.#.....#.#.....#.#.......#.#.R.#.#",
        "#.#####.#.###S###.#.#.#####.#.#.#######.#.#####.#.###.#.#######.#.###.###.#####.#",
        "#.......#.....#...#.#.#...#...#.....#...#.....#.#.#...#...#.....#...#...#...#e..#",
        "#.#####.#######B#####.#.###########.#.#######.#.#.#.###.###.#######.###.###.#.#.#",
        "#.....#.........#.....#.....#.....#.#...#...#...#.#...#...#.....#...#.....#.#.#.#",
        "#####.###########.#####.###.#.###.#.###.###.###.#.###.###.#####.#####.###.#.#.#.#",
        "#...#.....#.......#.#.....#.#...#.#...#.#.....#.#.#.......#...#...#...#...#.#.#.#",
        "###.#####.#.#######.#.#####N###.#.###.#.#.#####.#.#######.#.#.###.#.#######.#.#.#",
        "#...#.....#...#..o....#.#...#...#...#...#.#.....#.......#.#j#...#y#.......#.#.#.#",
        "#.###.#######.#.#######.#.###.###.#####.#.#.###########.###.#.###.#.#####.#.#X#.#",
        "#.............#........v#.......#.U.....#.Q...........#.....#.....#.....#.....#.#",
        "#################################################################################",
    ];

    //let _a = ["#########", "#b.A.@.a#", "#########"];
    let a = [
"#################",
"#i.G..c...e..H.p#",
"########.########",
"#j.A..b...f..D.o#",
"########@########",
"#k.E..a...g..B.n#",
"########.########",
"#l.F..d...h..C.m#",
"#################",


    ];

    let max_y: usize = a.len();
    let max_x: usize = a[0].len();

    let mut passages = HashSet::new();
    let mut doors = HashMap::new();
    let mut doors_inv = HashMap::new();
    let mut keys = HashMap::new();
    let mut keys_inv = HashMap::new();
    let mut curr = (0, 0);

    for y in 0..max_y {
        for x in 0..max_x {
            let c = a[y].chars().nth(x).unwrap();

            if c == '#' {
                continue;
            }
            passages.insert((x, y));
            if c == '@' {
                curr = (x, y);
            } else if 'a' <= c && c <= 'z' {
                keys.insert(c, (x, y));
                keys_inv.insert((x, y), c);
            } else if 'A' <= c && c <= 'Z' {
                doors.insert(c, (x, y));
                doors_inv.insert((x, y), c);
            }
        }
    }

    /*print!("\n\t");
    for x in 0..max_x {
        print!("{}", x / 10);
    }
    print!("\n\t");
    for x in 0..max_x {
        print!("{}", x % 10);
    }
    for y in 0..max_y {
        print!("\n{}\t", y);
        for x in 0..max_x {
            if doors_inv.contains_key(&(x, y)) {
                print!("{}", doors_inv[&(x, y)]);
            } else if keys_inv.contains_key(&(x, y)) {
                print!("{}", keys_inv[&(x, y)]);
            } else if curr.0 == x && curr.1 == y {
                print!("@");
            } else if passages.contains(&(x, y)) {
                print!(".");
            } else {
                print!("#");
            }
        }
    }
    print!("\n\n");*/

    //let mut queue = BinaryHeap::new();
    let mut queue = VecDeque::new();
    let found_keys = HashSet::new();
    let found_doors = HashSet::new();
    let mut visited = HashSet::new();

    visited.insert(curr);
    queue.push_front(State {
        pos: curr,
        steps: 0,
        found_keys: found_keys,
        found_doors: found_doors,
        visited: visited,
        path: vec![(curr.0, curr.1)]
    });
    let mut i = 0;
    while queue.len() > 0 {
        let mut should_ret = false;
        let mut should_cont = false;
        
        if i % 10 == 0 {
            //println!("q: {}; ", queue.len());
        }
        i += 1;

        let mut state = queue.pop_front().unwrap();
        let x = state.pos.0;
        let y = state.pos.1;
        
        //println!("pop ({} {})", x, y);

        if keys_inv.contains_key(&(x, y)) {  // it's a key
            let key = &keys_inv[&(x, y)];
            if state.found_keys.contains(key) { // already have this key
                // skip
                //println!("v1 ({} {})", x, y);
            } else { // didn't have this key
                state.found_keys.insert(*key);
                state.visited.clear();
                //println!("v2 ({} {})", x, y);
            }
        } else if doors_inv.contains_key(&(x, y)) { // it's a door
            let key = (doors_inv[&(x, y)] as u8 - 'A' as u8 + 'a' as u8) as char;
            
            if state.found_doors.contains(&key) { // already opened
                // skip
            } else { // closed door
                if state.found_keys.contains(&key) { // we have a key
                    state.found_doors.insert(key);
                    state.visited.clear();
                } else { // locked and no key - treat as a wall for now
                    should_cont = true;
                    state.visited.insert((x, y));
                    continue; 
                }
            }
        }
        
        state.visited.insert((x, y));

        if state.found_keys.len() == keys.len() {
            println!(
                "result: {} ({} == {})",
                state.steps,
                state.found_keys.len(),
                keys.len()
            );
            should_ret = true;
            return;
        }

        if !state.visited.contains(&(x, y + 1)) && passages.contains(&(x, y + 1)) {
            //println!("adding ({} {})", x, y + 1);
            let mut path = state.path.clone();
            path.push((x, y + 1));
            queue.push_back(State {
                pos: (x, y + 1),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
                path: path
            });
        }
        if !state.visited.contains(&(x, y - 1)) && passages.contains(&(x, y - 1)) {
            //println!("adding ({} {})", x, y - 1);
            let mut path = state.path.clone();
            path.push((x, y -1));
            queue.push_back(State {
                pos: (x, y - 1),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
                path: path
            });
        }
        
        if !state.visited.contains(&(x + 1, y)) && passages.contains(&(x + 1, y)) {
            //println!("adding ({} {})", x + 1, y);
            let mut path = state.path.clone();
            path.push((x + 1, y));
            queue.push_back(State {
                pos: (x + 1, y),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
                path: path
            });
        }
        if !state.visited.contains(&(x - 1, y)) && passages.contains(&(x - 1, y)) {
            //println!("adding ({} {})", x - 1, y);
            let mut path = state.path.clone();
            path.push((x - 1, y));
            queue.push_back(State {
                pos: (x - 1, y),
                steps: state.steps + 1,
                found_keys: state.found_keys.clone(),
                found_doors: state.found_doors.clone(),
                visited: state.visited.clone(),
                path: path
            });
        }
    }
}
